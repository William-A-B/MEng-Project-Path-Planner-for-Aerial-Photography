% Setup environment and algorithm constraints
% Size of environment
x_max = 100;
y_max = 100;

x_range = [0, x_max]; % meters
y_range = [0, y_max]; 
square_size = [20, 20]; % Each cuboid's dimensions

margin_size = 5; % Gap between squares

% square_step_size = square_size + margin_size;
square_step_size = square_size;

[x, y] = ndgrid(x_range(1):square_step_size(1):x_range(2), y_range(1):square_step_size(2):y_range(2));

square_centres = [x(:), y(:)];

square_corners = calculate_square_corner_coordinates(square_centres, square_size);

start_pos = [50, -20];
goal_pos = [50, 120];

% display2DGrid(start_pos, goal_pos, square_centres, square_step_size, square_corners, false)

figure;
hold on;
% Plot start and goal positions
plot(start_pos(1), start_pos(2), 'go', 'MarkerSize', 10, 'MarkerFaceColor', 'g'); % Start
plot(goal_pos(1), goal_pos(2), 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'r'); % Goal

% Draw squares at each center position in red
num_points = size(square_centres, 1);
for i = 1:num_points
    % Define bottom-left corner of square
    bottom_left = square_centres(i,:) - square_size / 4;

    % Draw red square
    rectangle('Position', [bottom_left, square_size/2], 'EdgeColor', 'c', 'LineWidth', 1);
end

% Plot cuboid centres
scatter(square_corners(:,1), square_corners(:,2), 20, 'filled', 'b');

index = 1;
start_coord = start_pos;
num_squares = size(square_centres, 1);

% Determine row length
square_row_length = sqrt(num_squares);

coordinate_path = zeros(num_squares+2, 2);
coordinate_path(1, :) = start_pos;

left_to_right = true; % Start moving left to right

connectionObj = uavDubinsConnection;
connectionObj.MaxRollAngle = 1.1;

prev_arrival_dir = 0;

for i = 1:(num_squares+1)
    % If all squares calculated for, find path to goal position
    if i == (num_squares + 1)
        closest_corner_coord = goal_pos;
    else
        % Find the distances between the start_coord and next set of corners
        distances = sqrt(sum((square_corners(index:index+3, :) - start_coord).^2, 2));
        % Calculate the index of the closest corner
        [~, closest_corner_index] = min(distances);
        % Get the closest corner coordinate from the corner index
        closest_corner_coord = square_corners((closest_corner_index-1)+index, :);
    end
    % Plot connecting line on graph
    % line([start_coord(1), closest_corner_coord(1)], [start_coord(2), closest_corner_coord(2)], 'LineWidth', 2, 'Color', 'c');
    
    [departure_dir, arrival_dir] = calculate_directions(start_coord, closest_corner_coord);
    
    start_pose = [start_coord, i, prev_arrival_dir];
    goal_pose = [closest_corner_coord, i, arrival_dir];
    prev_arrival_dir = arrival_dir;
    % Dubins Path
    [pathSegObj, pathCosts] = connect(connectionObj, start_pose, goal_pose);
    show(pathSegObj{1})

    % Update coordinate path array
    coordinate_path(i+1, :) = closest_corner_coord;
    % Update the new start coord
    start_coord = closest_corner_coord;
    
    % Detect end of row
    if mod(i, (square_row_length)) == 0
        % Switch row direction
        left_to_right = ~left_to_right;
        % Move up/down to the next row
        next_row_index = index + square_row_length * 4; % Move to next row
        if next_row_index <= size(square_corners, 1)
            index = next_row_index;
            continue; % Skip to next iteration
        end
    end

    % Move to the next square
    if left_to_right
        index = index + 4;  % Move forward
    else
        index = index - 4;  % Move backward
    end
end

% Labels and Grid
xlabel('X (m)');
ylabel('Y (m)');
title('Square centres and Start/Goal Positions');
grid on;
axis equal;
hold off;


function [square_corners] = calculate_square_corner_coordinates(square_centres, square_size)
    % Calculate square corners at each center position 
    num_squares = size(square_centres, 1);
    square_radius = square_size(1) / 4;
    square_corners = zeros(num_squares * 4, 2); % 4 corners per square
    index = 1;
    for i = 1:num_squares
        centre = square_centres(i, :);
        corners = [centre(1) - square_radius, centre(2) + square_radius;
                   centre(1) + square_radius, centre(2) + square_radius;
                   centre(1) + square_radius, centre(2) - square_radius;
                   centre(1) - square_radius, centre(2) - square_radius];
        square_corners(index:index+3, :) = corners;
        index = index + 4;
    end
end

function [departure_dir, arrival_dir] = calculate_directions(coord1, coord2)
    % Calculate direction vector
    direction_vector = coord2 - coord1;
    
    % Determine departure direction
    departure_dir = atan2(direction_vector(2), direction_vector(1));
    % Determine arrival direction (opposite of departure)
    arrival_dir = atan2(direction_vector(2), direction_vector(1));
end